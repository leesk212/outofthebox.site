---
tags: computer-architecture
toc: True
---
# Core
* CPU에서의 연산을 하는 장치
* Single core 하나의 연산 장치만 있음
* Clock -> CPU를 더 채직찔해서 빠르게 돌리는 것
* 2004 년도 이후 싱글코어의 clock을 높히는게 한계에 부딛힘
* 결국 싱글코어 손절하고 코어의 갯수를 늘리게됨
* 다수의 코어끼리의 통신을 늘리게됨
* Single core로 하지만 모든 프로그램들이 구성이 되어있었기에 최적화에 약간의 시간이 걸리게됨
* 그리고 각 코어의 성능이 2.0 이지만 듀얼코어를 해도 2.4의 성능밖에 나오지 않게됨 ( 상품성 의심 )
* 코어끼리 서로 일을 떠넘기거나, (일이 겹침) 현상등에 의해서 최적화된 성능이 나오지않음
* 멀티코어를 이용해도 돈도 적당히 남고, 성능도 조아야햄
* 2005년부터 멀티코어의 시대가 열리게됨
* CPU -> 4core -> 8thread
  * 각각의 모듈의 일을 나누어서 일을 하도록(멀티테스킹)하도록 하는 것
  * CPU의 thread는 제조사 기술의 이름이고
  * 프로그램의 thread는 소프트웨어 이름이다.
  
# 스레드
* 1개가 힘들면 2개를 같이한다 (자연스러운 생각임)
* 이때 2002년에 hyper threading에 대한 생각이 나오게된다.
* 하나의 코어를 통해서 두개의 일을 하는 것처럼 생각하도록 분리해서 일을 하도록 하는 것 ( 기술 이름임 )
* Intel -> Hyperthreading
* AMD -> SMT
* 하나의 코어를 두개의 일꾼이 일하는 것처럼 하이퍼스레딩을 하니 더 빨랐었어, 두명이 일을 하면 두개의 일을 실행시켰어
* 두개의 코어처럼 보이도록 하는 것
* 1코어 2스레드 (원래는 코어가 한개지만, 2개의 일꿀이 일하는 것처럼 보임)
* 2005년 --> 코어의 수를 늘렸지만 스레드는 같이 늘어나지 않았음
* 코어가 4개가 달렸지만 스레드는 4개 밖에 없어
* 그리고 이후헤 i7에 1개의 CPU에 2개의 thread가 있는 것 처럼 보임
* 6개의 코어의 스레드가 12개의 일을 하는 것 처럼 보이는 것 운영체제에서는 12개의 cpu가 일을 하는 것처럼 보임

# 코어가 많다고 빠를까??
* 가벼운 프로그램을 돌릴때는 상관이 없겠지만 
* 무거운 프로그램이 멀티코어 최적화가 안되어있다면 최대한의 성능을 일으킬수는 없을 것이다.
